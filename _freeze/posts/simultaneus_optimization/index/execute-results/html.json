{
  "hash": "9fb559c3307435966985e608101ce341",
  "result": {
    "markdown": "---\ntitle: \"R tutorial: Simultaneus Optimization of Several Response Variables\"\ncategories: [\"R\", \"tutorial\",\"simultaneus optimization\", \"response surface design\", \"desirability package\"]\ndate: \"2023-10-24\"\ndescription: 'A tutorial with R code to perform simultaneous optimization of several response variables'\ntoc: true\ntoc-location: left\n---\n\n\nThe data and code for this publication can be found in the following repository: <a href=\"https://github.com/juanpa-biotech/simultaneous-optimization\" target=\"_blank\">simultaneous-optimization</a>.\n\n# The problem of optimizing several response variables\n\nWhen we perform an experiment it is common to quantify more than one response variable in each of our experimental units. Depending on our objectives or needs, we might be interested in maximizing and/or minimizing some responses, while some others would only be measured to characterize the process, but we want them to stay within defined limits. How do we approach optimization taking into account each response variable? In other words, we want to find an optimal solution that allows us to find the best, or desirable, values for each response.\n\nOne way to solve the above problem is by means of the <a href=\"https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6217265/\" target=\"_blank\">desirability function method</a>, which allows us to obtain a global optimum taking into account all the response variables.\n\nIn general, the desirability function method consists of defining a function that covers the entire experimental region and estimates the global desirability ($GD$). The $GD$ in turn is defined taking into account all the responses, which allows to reduce a multivariate optimization problem to a single variable one. The objective becomes maximizing $GD$.\n\nTo define GD we first transform each predicted response $yp_i(x)$ into an individual desirability value $d_i(x)$ that falls in the interval $[0, 1]$. The transformation $d_i(x)$ of each response is performed according to the target values set by the investigator and measures the desirability at the experimental point or treatment $X = (x_1, x_2, x_3, ..., x_k)$, where each $x_i$ corresponds to each of the experimental factors considered in the design.\n\nIf the variable $yp_i(x)$ has an upper specification ($US_i$), a lower specification ($LS_i$) and its target value is $T_i$, the transformation $d_i(x)$ is defined as:\n\n![](img/eq_1.png){fig-align=\"center\"}\n\nThe exponents $s$ and $t$ are used to choose the form of the transformation. Assigning large values to these exponents, greater than or equal to 5, for example, will only yield desirability values close to 1 when $yp_i(x)$ is sufficiently close to the target value. On the other hand, selecting small values of $s$ and $t$ $(≤ 0.10)$ will yield desirability values close to 1 for a wide range of values within the interval $[LS_i, US_i]$. If both exponents are selected equal to 1, a linear increase in desirability will be obtained as the values of $yp_i(x)$ approach the target value.\n\nOnce the $m$ desirabilities have been calculated for the $m$ responses at the point within the experimental region $X_i$, the $GD$ at $X_i$ is defined by a weighted geometric mean:\n\n![](img/eq_2.png){fig-align=\"center\"}\n\nIn this case, the weights $w_i$ are constants that are assigned to balance the relative importance of each response variable compared to the others. The larger the value of $w$, the greater the requirement that the $GD$ result benefits that response. If we select a value of 1 for each $w$, the above equation reduces to:\n\n![](img/eq_3.png){fig-align=\"center\"}\n\nThe global optimum experimental point $X_0$ is the point at which the value of $GD(X_0)$ is maximum. To find this maximum value we apply a numerical method.\n\nWith this brief explanation of the method, it is now time to perform a practical example with R code. For this I will use the data published in <a href=\"https://www.tandfonline.com/doi/abs/10.1080/00224065.1980.11980968\" target=\"_balnk\">George Derringer & Ronald Suich (1980)</a>.\n\n# Packages\n\nFor this post I used the `readr`, `rsm`, `desirability` and `colorRamps` packages. If you haven't installed them you can run the following code to do so:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(c(\"readr\", \"rsm\", \"desirability\", \"colorRamps\"))\n```\n:::\n\n\n# Import data\n\nThe experimental data are in a CSV file and have the usual structure of a design matrix. To import the data from the repository of this post we can use the `read_csv()` function of the `readr` package:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readr)\n\ndata_tires <- read_csv(\"https://raw.githubusercontent.com/juanpa-biotech/simultaneous-optimization/master/data_tires.csv\")\n\nhead(data_tires)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 7\n     x1    x2    x3    Y1    Y2    Y3    Y4\n  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n1    -1    -1     1   102   900   470  67.5\n2     1    -1    -1   120   860   410  65  \n3    -1     1    -1   117   800   570  77.5\n4     1     1     1   198  2294   240  74.5\n5    -1    -1    -1   103   490   640  62.5\n6     1    -1     1   132  1289   270  67  \n```\n:::\n:::\n\n\nThe data correspond to an experiment whose objective is to improve the formulation of belts for the manufacture of tires, so that certain quality parameters are met. The $x_i$ correspond to the factors and the $Y_i$ to the responses.\n\nThe information in the columns is as follows:\n\n-   $x1$: level of hydrated silica.\n-   $x2$: level of silane coupling agent\n-   $x3$: sulfur level\n-   $Y1$: PICO abrasion index\n-   $Y2$: modulus 200\n-   $Y3$: elongation at break\n-   $Y4$: hardness\n\nWe look for the values of each response variable to meet the following requirements:\n\n-   $Y1 > 120$\n-   $Y2 > 1000$\n-   $400 < Y3 < 600$\n-   $60 < Y4 < 75$\n\nThus we could ask the question: Which treatment (combination of the $x_i$) within our experimental region would allow us to achieve the above specifications?\n\n# Second-order model fitting\n\nIt is important to note that the experimental design that corresponds to our data is a response surface design, so we fit second-order models for each response using the `rsm` package:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rsm)\n\ny1_m  <- rsm(Y1 ~ SO(x1, x2, x3), data = data_tires)\ny2_m  <- rsm(Y2 ~ SO(x1, x2, x3), data = data_tires)\ny3_m  <- rsm(Y3 ~ SO(x1, x2, x3), data = data_tires)\ny4_m  <- rsm(Y4 ~ SO(x1, x2, x3), data = data_tires)\n```\n:::\n\n\nThe models for each response follow the general equation:\n\n![](img/eq_4.png){fig-align=\"center\"}\n\nTo get an idea of the variability explained by each model I defined a small function that returns the coefficient of determination and the fitted coefficient of determination for a given model:  \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get a R^2 and adjusted R^2 from a linear model\nget_r2 <- function(model){\n  sum_model <- summary(model)\n  round(c(R2 = sum_model$r.squared, adj.R2 = sum_model$adj.r.squared), 3)\n}\n\n# Table with R-squared for each model\ny1_r2 <- get_r2(y1_m)\ny2_r2 <- get_r2(y2_m)\ny3_r2 <- get_r2(y3_m) \ny4_r2 <- get_r2(y4_m)\n\nr2t <- t(data.frame(y1_m = y1_r2, y2_m = y2_r2, y3_m = y3_r2, y4_m = y4_r2))\nr2t\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        R2 adj.R2\ny1_m 0.972  0.947\ny2_m 0.742  0.510\ny3_m 0.981  0.965\ny4_m 0.958  0.921\n```\n:::\n:::\n\nAs can be seen in the table, the coefficients of determination of the $Y2$ model are lower than the rest. This should be taken into account, as there could be another model that fits the $Y2$ data better. However, for learning purposes I used all quadratic models as was done in the Derringer & Suich (1980) paper.\n\n# Simultaneous optimization\n\n## Definition of functions for simultaneous optimization\n\nFor simultaneous optimization I defined a couple of functions. First a prediction function:  \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Prediction function\nrsm_opt <- function(x, dObject, space = \"square\"){\n  \n  df <- data.frame(x1 = x[1], x2 = x[2], x3 = x[3])\n  \n  y1 <- predict.lm(y1_m, df)\n  y2 <- predict.lm(y2_m, df)\n  y3 <- predict.lm(y3_m, df)\n  y4 <- predict.lm(y4_m, df)\n  \n  out <- predict(dObject, data.frame(y1 = y1, y2 = y2, y3 = y3, y4 = y4))\n  \n  if(space == \"circular\" & sqrt(sum(x^2)) > 1.63) out <- 0\n  else if(space == \"square\" & any(abs(x) > 1.63)) out <- 0 \n  \n  out\n}\n```\n:::\n\n\nThis function specifies two possible shapes for the experimental region: *square* and *circular*. This must be taken into account and may vary according to our experimental design.  \n\nSubsequently, I defined a function that will be in charge of finding the best global desirability value:  \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Optimization function\nmaximize_overall <- function(int_1 = c(-1.63, 1.63),\n                             int_2 = c(-1.63, 1.63),\n                             int_3 = c(-1.63, 1.63),\n                             dObject = NULL, \n                             space = \"square\"){\n  \n  searchGrid <- expand.grid(\n    x1 = seq(int_1[1], int_1[2], length.out = 5),\n    x2 = seq(int_2[1], int_2[2], length.out = 5),\n    x3 = seq(int_3[1], int_3[2], length.out = 5)\n  )\n  \n  for(i in 1:dim(searchGrid)[1]){\n    \n    tmp <- optim(as.vector(searchGrid[i,]),\n                 rsm_opt,\n                 dObject = dObject,\n                 space = space, \n                 control = list(fnscale = -1))\n    \n    if(i == 1) best <- tmp\n    if(tmp$value > best$value) best <- tmp\n  }\n  \n  best\n}\n```\n:::\n\n\nNote that in the previous functions I took into account the maximum and minimum coded values of each factor, in this case 1.63 and -1.63, respectively. If you wish to use this code with your own data do not forget to modify these values according to your experimental design.  \n\n## Definition of desirability functions\n\nWith the functions included in the desirability package we define a desirability function for each response as follows:  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(desirability)\n\nD_y1 <- dMax(120, 170)\nD_y2 <- dMax(1000, 1300)\nD_y3 <- dTarget(400, 500, 600)\nD_y4 <- dTarget(60, 67.5, 75)\n```\n:::\n\n\nEach target value was set for convenience and was sought to meet the above specifications as outlined in Derringer & Suich (1980).  \n\nGlobal desirability is in turn defined by taking into account the above functions:  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nD_overall <- dOverall(D_y1, D_y2, D_y3, D_y4)\n```\n:::\n\n\n## Carrying out simultaneous optimization\n\nWith the previously defined functions we proceed to perform the simultaneous optimization:  \n\n\n::: {.cell hash='index_cache/html/simultaneous optimization_a670352e2c96906e3dc168df01003c47'}\n\n```{.r .cell-code}\noverall_opt <- maximize_overall(dObject = D_overall)\n```\n:::\n\n\nDepending on your data and the specifications of your computer, this process may be a bit slow.  \n\nThe processing that allows you to obtain the maximum overall desirability can be deployed directly:  \n\n\n::: {.cell}\n\n```{.r .cell-code}\noverall_opt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$par\n         x1          x2          x3 \n-0.05345891  0.14718872 -0.86635592 \n\n$value\n[1] 0.5833527\n\n$counts\nfunction gradient \n     502       NA \n\n$convergence\n[1] 1\n\n$message\nNULL\n```\n:::\n:::\n\n`$value` refers to the overall desirability value obtained. This result is practically the same as that published in the Derringer & Suich paper.  \n\n# Obtaining predictions of each response variable in the global optimum\n\nWe can obtain a prediction for each response at the global optimum point:  \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Optimal point as a data frame\ndata_opt <- data.frame(\n  x1 = overall_opt$par[1],\n  x2 = overall_opt$par[2],\n  x3 = overall_opt$par[3]\n  )\n\n# Predict each response at overall optimization point\ny1_opt <- predict.lm(y1_m, data_opt)\ny2_opt <- predict.lm(y2_m, data_opt)\ny3_opt <- predict.lm(y3_m, data_opt)\ny4_opt <- predict.lm(y4_m, data_opt)\n\n# Response predictions in a data frame\nres_opt <- data.frame(y1_opt, y2_opt, y3_opt, y4_opt)\nrownames(res_opt) <- \"Optimal responses\"\nround(res_opt, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                  y1_opt y2_opt y3_opt y4_opt\nOptimal responses 129.43   1300 465.97  68.02\n```\n:::\n:::\n\nMission accomplished. All of these values meet the established specifications.  \n\nIt may also be useful to obtain the individual desirabilities of each response:  \n\n::: {.cell}\n\n```{.r .cell-code}\n# Optimal desirability values \nd1_opt <- predict(D_y1, y1_opt)\nd2_opt <- predict(D_y2, y2_opt)\nd3_opt <- predict(D_y3, y3_opt)\nd4_opt <- predict(D_y4, y4_opt)\n\nd_opts <- data.frame(d1_opt, d2_opt, d3_opt, d4_opt)\nrownames(d_opts) <- \"Optimal desiabilities\"\nround(d_opts, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                      d1_opt d2_opt d3_opt d4_opt\nOptimal desiabilities  0.189      1   0.66  0.931\n```\n:::\n:::\n\nFinally, all predictions must be tested experimentally. For this purpose, it should be considered whether it is possible to adjust the level of each factor to the optimum obtained by simultaneous optimization. If, due to technical limitations, it is not possible to perform the optimal treatment, an alternative could be to evaluate an experimental point that can be fixed in practice and is close to the global optimum obtained. In these cases it would be useful to know how global desirability behaves within our experimental region.  \n\n# Desirability function display\n\nTo perform the desirability function visualizations I also defined a couple of functions:  \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generate a matrix with desirability predictions within the experimental region\nd_matrix <- function(model_1, model_2, model_3, model_4, \n                     dObject,  c3 = -1, l_x = c(-1, 1), by = 0.1){\n  \n  x <- seq(l_x[1], l_x[2], by = by)\n  lx <- length(x)\n  \n  data_x <- expand.grid(x1 = x, x2 = x, x3 = c3)\n  \n  y_1 <- predict(y1_m, data_x)\n  y_2 <- predict(y2_m, data_x)\n  y_3 <- predict(y3_m, data_x)\n  y_4 <- predict(y4_m, data_x)\n  \n  d_m <- predict(D_overall, data.frame(Y1 = y_1, Y2 = y_2, Y3 = y_3, Y4 = y_4))\n  dim(d_m) <- c(lx, lx)\n  \n  list(d_m = d_m, x = x)\n}\n\n# Deploys a contour plot for desirability within the experimental region\ncontour_d <- function(data = NULL, main = \" \",  xlab = \"x1\", ylab = \"x2\"){\n  filled.contour(\n    z = data$d_m, x = data$x, y = data$x, \n    color.palette = colorRamps::matlab.like,\n    plot.title = title(main = main, xlab = xlab, ylab = ylab, cex.lab = 1.5, \n                       cex.main = 1.5),\n    plot.axes = {\n      axis(1, cex.axis = 1.5)\n      axis(2, cex.axis = 1.5)\n    }\n  )\n}\n```\n:::\n\nSince we are dealing with three factors, we set the value of $x3$ as a constant in the values -1, 0 and 1 for the contour plots.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Desirability at x3 = -1\ndpx3_1 <- d_matrix(y1_m, y2_m, y3_m, y4_m, D_overall, \n                   c3 = -1, l_x = c(-1.6, 1.6))\ncontour_d(dpx3_1, main = \"x3 = -1\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/d contour x3 at -1-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Desirability at x3 = 0\ndpx3_2 <- d_matrix(y1_m, y2_m, y3_m, y4_m, D_overall, \n                   c3 = 0, l_x = c(-1.6, 1.6))\ncontour_d(dpx3_2, main = \"x3 = 0\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/d contour x3 at 0-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Desirability at x3 = 1\ndpx3_3 <- d_matrix(y1_m, y2_m, y3_m, y4_m, D_overall, \n                   c3 = 1, l_x = c(-1.6, 1.6))\ncontour_d(dpx3_3, main = \"x3 = 1\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/d contour x3 at 1-1.png){width=672}\n:::\n:::\n\nNote that these functions can also be adapted for any number of response variables and for any number of factors.  \n\n# Key points\n\n* When conducting an experiment it is usual to measure several response variables. It is also usual to seek to maximize or minimize certain responses while keeping others within specific limits.\n* The desirability function method seeks an optimal solution considering all response variables. It converts the multivariate problem into a univariate problem by defining a global desirability function.\n* For this, the responses are transformed into desirability values ranging from 0 to 1 according to the researcher's objectives. Subsequently, the global desirability is calculated as a weighted average of the individual desirabilities, and the global optimum is sought by numerical methods.\n* A practical example is provided in R related to the formulation of tire belts using the `rsm` and `desirability` packages.\n* It is possible to visualize the desirability function by means of contour plots.\n\nThe code on this post is licensed under the [Creative Commons Attribution 4.0 International License](http://creativecommons.org/licenses/by/4.0/)\n\n[![](https://img.shields.io/badge/License-CC%20BY%204.0-lightgrey.svg)](http://creativecommons.org/licenses/by/4.0/)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}